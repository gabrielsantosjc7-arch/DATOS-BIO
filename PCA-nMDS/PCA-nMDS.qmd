# Cargar dataset
df_raw <- penguins %>% as_tibble()
```
## Preparación de datos y verificación de supuestos

```{r}
#| label: pca_prep

# --- Preparación de datos ---
df_pca <- df_raw %>%
  select(species, island, bill_length_mm, bill_depth_mm, 
         flipper_length_mm, body_mass_g) %>%
  drop_na()
```

```{r}
#| label: tbl-pca-norm
#| tbl-cap: "Normalidad multivariada (test de Mardia)"
#| warning: false
#| message: false

# Test de normalidad multivariada (Mardia)
mardia_test <- MVN::mvn(
  data = df_pca[, 3:6],
  mvn_test = "mardia",     
  univariate_test = "AD",
  descriptives = FALSE,
  tidy = TRUE
)

norm_tbl <- mardia_test$multivariate_normality %>%
  dplyr::select(Test, Statistic, p.value, MVN) %>%
  dplyr::mutate(across(where(is.numeric), round, 3))


knitr::kable(norm_tbl)
```{r}
#| label: tbl-pca-bartlett-kmo
#| tbl-cap: "Pruebas de esfericidad y adecuación muestral"
#| warning: false
#| message: false

# Esfericidad (Bartlett) y adecuación muestral (KMO)

bart <- psych::cortest.bartlett(cor(df_pca[, 3:6]), n = nrow(df_pca))
kmo  <- psych::KMO(cor(df_pca[, 3:6]))

sphere_tbl <- tibble(
  Test = c("Bartlett’s test of sphericity", "Kaiser-Meyer-Olkin (KMO)"),
  Statistic = c(round(bart$chisq, 3), NA),
  df = c(bart$df, NA),
  p_value = c(ifelse(bart$p.value < 0.001, "<0.001", round(bart$p.value, 3)), NA),
  Measure = c(NA, round(kmo$MSA, 3))
)

knitr::kable(sphere_tbl)
```{r}
#| label: fig-pca-corr
#| warning: false
#| message: false
#| fig-cap: "Matriz de correlaciones entre variables morfométricas (Spearman)"
#| fig-width: 6
#| fig-height: 5

# Matriz de correlaciones (ggcorrplot)

cor_mat <- cor(df_pca[, 3:6], method = "spearman", 
               use = "pairwise.complete.obs")

ggcorrplot(
  cor_mat, 
  hc.order = TRUE, 
  type = "lower", 
  lab = TRUE,
  lab_size = 3,
  method = "square",
  colors = c("#6D9EC1", "white", "#E46726"),
  title = "Matriz de correlaciones (Spearman)",
  ggtheme = ggplot2::theme_minimal()
)
```
## Ejecutar PCA con `prcomp()` y extraer resultados

```{r}
#| label: tbl-pca-fit
#| tbl-cap: "Desviaciones, varianza y proporción por componente"

pca_fit <- prcomp(df_pca %>% select(where(is.numeric)), scale. = TRUE, 
                  center = TRUE)

# Varianza explicada
pca_var <- pca_fit$sdev^2
pca_var_prop <- pca_var / sum(pca_var)

pca_summary <- tibble(
  PC = paste0("PC", seq_along(pca_var)),
  sdev = round(pca_fit$sdev, 3),
  variance = round(pca_var, 3),
  prop.var = round(pca_var_prop, 3),
  cum.var = round(cumsum(pca_var_prop), 3)
)

knitr::kable(pca_summary)

```

## Gráficos: screeplot y biplot (scores + loadings)

```{r}
#| label: fig-pca-scree
#| fig-cap: "Screeplot PCA"

# Screeplot
scree_df <- pca_summary
ggplot(scree_df, aes(x = as.numeric(gsub("PC","",PC)), y = prop.var)) +
  geom_col() +
  geom_line(aes(y = cum.var), color = "blue") +
  geom_point(aes(y = cum.var), color = "blue") +
  labs(x = "Componente principal", y = "Proporción de varianza explicada",
       title = "Screeplot PCA") +
  theme_minimal()

```
```{r}
#| label: tbl-pca-loadings
#| tbl-cap: "Contribución de las variables a los componentes principales"
#| warning: false
#| message: false

# Cargas (loadings) de cada variable en las primeras dos componentes
loadings_tbl <- as_tibble(pca_fit$rotation[, 1:2], rownames = "Variable") %>%
  rename(PC1 = PC1, PC2 = PC2) %>%
  mutate(across(where(is.numeric), round, 3))

knitr::kable(loadings_tbl)

```{r}
#| label: fig-pca-biplot
#| fig-cap: "Biplot PCA: relación entre variables y componentes principales"
#| warning: false
#| message: false
#| fig-width: 7
#| fig-height: 6

# Biplot de variables
biplot_data <- as_tibble(pca_fit$x[, 1:2]) %>%
  mutate(species = df_pca$species)

# vectores de las variables (loadings)
loadings <- as.data.frame(pca_fit$rotation[, 1:2])

ggplot(biplot_data, aes(PC1, PC2, color = species)) +
  geom_point(alpha = 0.7, size = 2) +
  geom_segment(data = loadings,
               aes(x = 0, y = 0, xend = PC1 * 3, yend = PC2 * 3),
               arrow = arrow(length = unit(0.25, "cm")), 
               color = "black") +
  geom_text_repel(data = loadings,
                  aes(x = PC1 * 3.2, y = PC2 * 3.2, label = rownames(loadings)),
                  color = "black", size = 3.5) +
  labs(title = "Biplot PCA: especies y variables morfométricas",
       x = "Componente 1",
       y = "Componente 2") +
  theme_minimal() +
  theme(legend.position = "bottom")

```
# Hellinger transforma abundancias para métodos basados en distancia euclidiana,
varespec_hel <- decostand(varespec, method = "hellinger")
```

## Ejecutar NMDS con `metaMDS()` (Bray-Curtis por defecto)

```{r}
#| label: nmds-stress
#| warning: false
#| message: false
#| results: hide


# Ajuste del NMDS (sin mostrar mensajes de ejecución)
set.seed(42)
suppressMessages({
  capture.output({
    nmds <- metaMDS(
      varespec_hel,
      distance = "bray",
      k = 2,
      trymax = 100,
      autotransform = FALSE
    )
  })
})
```

```{r}
#| label: fig-nmds-stress
#| fig-cap: "Curva de ajuste NMDS (stressplot) para evaluar la calidad del ordenamiento"
#| warning: false
#| message: false
#| fig-width: 6
#| fig-height: 5

# Curva de ajuste (stressplot)
vegan::stressplot(nmds)
```
## Visualización NMDS: sitios + especies + envfit

```{r}
#| label: tbl-nmds-envfit
#| tbl-cap: "Resultados del ajuste de variables ambientales (envfit) sobre el espacio NMDS"

# Ajustar variables ambientales (envfit)
ef <- envfit(nmds, varechem, permutations = 999)

# Extraer resultados del envfit
ef_results <- as.data.frame(ef$vectors$arrows)
ef_r2 <- ef$vectors$r
ef_p <- ef$vectors$pvals

# Crear tabla resumen
tabla_envfit <- ef_results %>%
  rownames_to_column("Variable") %>%
  mutate(
    R2 = round(ef_r2, 3),
    p_value = signif(ef_p, 3),
    NMDS1 = round(NMDS1, 3),
    NMDS2 = round(NMDS2, 3)
  ) %>%
  arrange(desc(R2))

knitr::kable(
  tabla_envfit,
  align = "lcccc"
)

```
```{r}
#| label: fig-nmds-biplot
#| fig-cap: "Ordenamiento NMDS basado en distancias de Bray–Curtis, con ajuste de variables ambientales mediante envfit"
#| warning: false
#| message: false
#| fig-width: 7
#| fig-height: 6

# Extraer coordenadas de sitios
sites_scores <- as_tibble(scores(nmds, display = "sites")) %>%
  mutate(site = rownames(varespec))

# Extraer coordenadas de especies
species_scores <- as_tibble(scores(nmds, display = "species")) %>%
  rownames_to_column("species")

# Ajustar variables ambientales (envfit)
ef <- envfit(nmds, varechem, permutations = 999)

# Mantener nombres correctos de variables ambientales
ef_arrows <- as.data.frame(ef$vectors$arrows)
ef_arrows$var <- rownames(ef_arrows)
ef_arrows <- ef_arrows %>%
  as_tibble() %>%
  rename(NMDS1 = NMDS1, NMDS2 = NMDS2)

# Gráfico NMDS con vectores ambientales
ggplot(sites_scores, aes(x = NMDS1, y = NMDS2)) +
  geom_point(size = 3, alpha = 0.8) +
  geom_text_repel(aes(label = site), size = 3, max.overlaps = 15) +
  geom_segment(
    data = ef_arrows,
    aes(x = 0, y = 0, xend = NMDS1, yend = NMDS2),
    arrow = arrow(length = unit(0.25, "cm")),
    color = "black"
  ) +
  geom_text_repel(
    data = ef_arrows,
    aes(x = NMDS1, y = NMDS2, label = var),
    size = 3,
    color = "black"
  ) +
  labs(
    title = paste0("NMDS (stress = ", round(nmds$stress, 3), ")"),
    x = "NMDS1",
    y = "NMDS2"
  ) +
  theme_minimal()
