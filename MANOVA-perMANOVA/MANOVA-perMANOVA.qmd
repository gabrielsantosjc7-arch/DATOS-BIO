## Preparación MANOVA

```{r}
#| label: manova_prep
#| echo: true
#| warning: false
#| message: false

# Datos
data("iris")
df_manova <- iris %>% as_tibble()

# Transformaciones propuestas: log10 de Sepal.Length y Sepal.Width
df_manova <- df_manova %>%
  mutate(
    Sepal.LengthLog10 = log10(Sepal.Length),
    Sepal.WidthLog10  = log10(Sepal.Width)
  )

```

## Verificación de supuestos

```{r}
#| label: tbl-manova-mvn-mult
#| tbl-cap: "Normalidad multivariada por especie (test de Mardia)"
#| warning: false
#| message: false
#| echo: true

# Función segura para extraer resultados MVN::mvn en formato consistente
mvn_by_group <- function(data, group_var, vars) {
  groups <- unique(data[[group_var]])
  out <- map_dfr(groups, function(g) {
    sub <- data %>% filter((!!sym(group_var)) == g) %>% select(all_of(vars))
    # usamos mvn con mvn_test = "mardia", univariate_test = "AD" 
    res <- tryCatch(
      MVN::mvn(sub, mvn_test = "mardia", univariate_test = "AD", 
               descriptives = FALSE, tidy = TRUE),
      error = function(e) return(NULL)
    )
    if (is.null(res)) {
      tibble(Especie = as.character(g), Test = NA, Statistic = NA, 
             p.value = NA, MVN = NA)
    } else {
      df <- res$multivariate_normality
      tibble(
        Especie = as.character(g),
        Test = df$Test,
        Statistic = round(as.numeric(df$Statistic), 3),
        p.value = ifelse(df$p.value < 0.001, "< 0.001", 
                         round(as.numeric(df$p.value), 3)),
        MVN = df$MVN
      )
    }
  })
  out
}

vars_manova <- c("Sepal.LengthLog10", "Sepal.WidthLog10")
lda_mvn_mult_tbl <- mvn_by_group(df_manova, "Species", vars_manova)
knitr::kable(lda_mvn_mult_tbl)
```{r}
#| label: tbl-manova-mvn-uni
#| tbl-cap: "Normalidad univariada por especie (Anderson–Darling)"
#| warning: false
#| message: false
#| echo: true

# Extraer univar de MVN::mvn por especie (AD)
mvn_univar_by_group <- function(data, group_var, vars) {
  groups <- unique(data[[group_var]])
  map_dfr(groups, function(g) {
    sub <- data %>% filter((!!sym(group_var)) == g) %>% select(all_of(vars))
    res <- tryCatch(
      MVN::mvn(sub, mvn_test = "mardia", univariate_test = "AD", 
               descriptives = FALSE, tidy = TRUE),
      error = function(e) return(NULL)
    )
    if (is.null(res)) {
      tibble(Especie = as.character(g), Test = NA, Variable = NA, 
             Statistic = NA, p.value = NA, Normality = NA)
    } else {
      df <- res$univariate_normality %>% as_tibble()
      df %>%
        mutate(Especie = as.character(g),
               p.value = ifelse(p.value < 0.001, "< 0.001", 
                                round(as.numeric(p.value), 3))) %>%
        select(Especie, Test, Variable, Statistic, 
               p.value, Normality)
    }
  })
}

lda_mvn_uni_tbl <- mvn_univar_by_group(df_manova, "Species", vars_manova)
knitr::kable(lda_mvn_uni_tbl)

```{r}
#| label: tbl-manova-boxm
#| tbl-cap: "Test de Box: homogeneidad de matrices de covarianza (variables log10)"
#| warning: false
#| message: false
#| echo: true

# Box's M sobre las dos variables transformadas
boxm_res <- boxM(
  df_manova %>% select(Sepal.LengthLog10, Sepal.WidthLog10),
  grouping = df_manova$Species
)

# Extraer y presentar en formato tabla
boxm_tbl <- tibble(
  Estadistico = "Chi-sq (aprox.)",
  Valor = round(boxm_res$statistic, 2),
  df = boxm_res$parameter,
  p_value = ifelse(boxm_res$p.value < 0.001, "< 0.001", 
                   signif(boxm_res$p.value, 3))
)
```{r}
#| label: tbl-manova-outliers
#| tbl-cap: "Detección de outliers multivariados (Mahalanobis) por especie"
#| warning: false
#| message: false
#| echo: true

# Calcular Mahalanobis por especie para las dos variables log10
out_list <- map_dfr(unique(df_manova$Species), function(sp) {
  sub <- df_manova %>% filter(Species == sp) %>% select(all_of(vars_manova))
  center <- colMeans(sub)
  covm <- cov(sub)
  m <- mahalanobis(sub, center, covm)
  tibble(Especie = sp, idx = which(df_manova$Species == sp), 
         mahalanobis = m)
})

# Umbral con p = 0.999 y df = número de variables (2)
thr <- qchisq(0.999, df = length(vars_manova))

outliers_tbl <- out_list %>%
  mutate(is_outlier = mahalanobis > thr) %>%
  filter(is_outlier) %>%
  left_join(df_manova %>% mutate(idx = row_number()), 
            by = c("idx" = "idx")) %>%
  select(Especie, row = idx, mahalanobis) %>%
  mutate(mahalanobis = round(mahalanobis, 2))

if (nrow(outliers_tbl) == 0) {
  outliers_tbl <- tibble(Especie = character(), row = integer(), 
                         mahalanobis = numeric())
}

knitr::kable(outliers_tbl)

## MANOVA

```{r}
#| label: tbl-manova-fit
#| tbl-cap: "Resultado MANOVA (test de Pillai) — modelo: cbind(Sepal.LengthLog10, Sepal.WidthLog10) ~ Species"
#| warning: false
#| message: false
#| echo: true

# Ejecutar MANOVA
man_mod <- manova(cbind(Sepal.LengthLog10, Sepal.WidthLog10) ~ Species, 
                  data = df_manova)

# Intentar usar broom::tidy()
manova_tbl <- tryCatch(
  broom::tidy(man_mod, test = "Pillai"),
  error = function(e) tibble()
)

# Si broom falla o no devuelve columnas esperadas → crear tabla manual
if (nrow(manova_tbl) == 0 || !"p.value" %in% names(manova_tbl)) {
  s <- summary(man_mod, test = "Pillai")
  manova_tbl <- tibble(
    term = rownames(s$stats),
    Pillai = round(s$stats[, "Pillai"], 3),
    approx_F = round(s$stats[, "approx F"], 3),
    df1 = s$stats[, "df1"],
    df2 = s$stats[, "df2"],
    p_value = s$stats[, "Pr(>F)"]
  )
}

# Forzar formato del p-valor (menor a 0.05)
manova_tbl <- manova_tbl %>%
  mutate(
    p.value = ifelse(p.value < 0.05, "< 0.05", round(p.value, 3))
  )

knitr::kable(manova_tbl)

```{r}
#| label: tbl-manova-posthoc
#| tbl-cap: "Comparaciones post-hoc Sepal.LengthLog10 (emmeans, ajuste Holm)"
#| warning: false
#| message: false
#| echo: true

# Modelo lineal y comparaciones post-hoc (emmeans)
fit_len <- lm(Sepal.LengthLog10 ~ Species, data = df_manova)
em_len <- emmeans(fit_len, pairwise ~ Species, adjust = "holm")
len_comp <- as.data.frame(em_len$contrasts) %>%
  mutate(
    across(where(is.numeric), ~ round(., 4)),
    p.value = ifelse(p.value < 0.05, "< 0.05", round(p.value, 4))
  )

knitr::kable(len_comp)
```{r}
#| label: tbl-manova-posthoc2
#| tbl-cap: "Comparaciones post-hoc Sepal.WidthLog10 (emmeans, ajuste Holm)"
#| warning: false
#| message: false
#| echo: true

# Modelo lineal y comparaciones post-hoc (emmeans)
fit_wid <- lm(Sepal.WidthLog10 ~ Species, data = df_manova)
em_wid <- emmeans(fit_wid, pairwise ~ Species, adjust = "holm")
wid_comp <- as.data.frame(em_wid$contrasts) %>%
  mutate(
    across(where(is.numeric), ~ round(., 4)),
    p.value = ifelse(p.value < 0.05, "< 0.05", round(p.value, 4))
  )

knitr::kable(wid_comp)

```{r}
#| label: fig-manova-means
#| fig-cap: "Medias (log10) por especie — Sepal.LengthLog10 y Sepal.WidthLog10"
#| fig-width: 7
#| fig-height: 4
#| warning: false
#| message: false
#| echo: true

# Preparar datos para gráfico
plot_df <- df_manova %>%
  select(Species, Sepal.LengthLog10, Sepal.WidthLog10) %>%
  pivot_longer(-Species, names_to = "variable", values_to = "value")

ggplot(plot_df, aes(x = Species, y = value, fill = Species)) +
  stat_summary(fun = mean, geom = "bar", 
               position = position_dodge(width = 0.8)) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar",
               position = position_dodge(width = 0.8), 
               width = 0.2) +
  facet_wrap(~variable, scales = "free_y") +
  theme_minimal() +
  theme(legend.position = "none")

```
## perMANOVA

```{r}
#| label: tbl-permanova
#| tbl-cap: "Resultado perMANOVA — modelo: Sepal.Length + Sepal.Width ~ Species"
#| echo: true
#| warning: false
#| message: false

# perMANOVA: diferencias multivariadas entre especies

# Base de datos (usa df_manova si ya la tienes del MANOVA)
data("iris")
df_permanova <- df_manova %>%
  select(Sepal.Length, Sepal.Width, Species)

# Ejecutar perMANOVA (distancia euclidiana)
set.seed(123)
permanova_res <- adonis2(df_permanova[,1:2] ~ Species,
                         data = df_permanova,
                         method = "euclidean")

# Convertir a tibble para tabla
permanova_tbl <- as_tibble(permanova_res, rownames = "Term") %>%
  mutate(
    across(where(is.numeric), ~ round(., 4)),
    `Pr(>F)` = ifelse(`Pr(>F)` < 0.05, "< 0.05", round(`Pr(>F)`, 4))
  )

knitr::kable(permanova_tbl)

```
```{r}
#| label: permanova-posthoc-run
#| warning: false
#| message: false
#| echo: true
#| include: false

# Ejecutar pairwise.perm.manova()
suppressMessages(
  suppressWarnings(
    posthoc_permanova <- RVAideMemoire::pairwise.perm.manova(
      df_permanova[, 1:2],
      df_permanova$Species,
      nperm = 999,
      p.method = "bonf"
    )
  )
)

```

```{r}
#| label: tbl-permanova-posthoc
#| tbl-cap: "Comparaciones post-hoc perMANOVA (ajuste Bonferroni)"
#| warning: false
#| message: false
#| echo: true

# Función auxiliar que intenta extraer la matriz de p-valores de las distintas
# estructuras que puede devolver pairwise.perm.manova()
extract_pairwise_pvals <- function(obj) {
  # 1) posibilidad: $P (matriz)
  if (!is.null(obj$P)) {
    return(as.matrix(obj$P))
  }
  # 2) posibilidad: $Ps
  if (!is.null(obj$Ps)) {
    return(as.matrix(obj$Ps))
  }
  # 3) posibilidad: $p.value
  if (!is.null(obj$`p.value`)) {
    return(as.matrix(obj$`p.value`))
  }
  # 4) intentar encontrar la primera matriz numérica en la lista
  mats <- Filter(function(x) is.matrix(x) || is.data.frame(x), obj)
  if (length(mats) > 0) {
    mm <- as.matrix(mats[[1]])
    # si es una matriz triangular con NAs, devolverla
    if (is.numeric(mm)) return(mm)
  }
  # 5) intentar parsear la impresión textual (último recurso)
  if (!is.null(posthoc_raw_print) && length(posthoc_raw_print) > 0) {
    # Buscar líneas que parezcan filas de matriz (números con espacios)
    lines <- posthoc_raw_print
    # heurística simple: tomamos las últimas 4 líneas con números
    nums_lines <- grep("\\d+\\.\\d+|< 0\\.0", lines, value = TRUE)
    if (length(nums_lines) >= 1) {
      # no es perfecto; devolvemos NULL para fallback
      return(NULL)
    }
  }
  return(NULL)
}

pv_mat <- extract_pairwise_pvals(posthoc_permanova)

if (!is.null(pv_mat)) {
  # Convertir a tabla larga
  ptab <- as.data.frame(pv_mat) %>%
    tibble::rownames_to_column("Especie1") %>%
    tidyr::pivot_longer(-Especie1, names_to = "Especie2", 
                        values_to = "pval") %>%
    dplyr::filter(!is.na(pval) & Especie1 != Especie2) %>%
    dplyr::mutate(
      Comparación = paste(Especie1, Especie2, sep = " - "),
      p.value = ifelse(as.numeric(pval) < 0.05, "< 0.05", 
                       format(round(as.numeric(pval), 4), nsmall = 4))
    ) %>%
    dplyr::select(Comparación, p.value) %>%
    dplyr::distinct()
} else {
  ptab <- tibble(
    Comparación = "No se pudo extraer la matriz de p-valores 
    del objeto devuelto",
    p.value = "ver output crudo"
  )
}

knitr::kable(ptab)

```
```{r}
#| label: fig-permanova-centroides
#| fig-cap: "Dispersión y centroides por especie — Sepal.Length vs Sepal.Width"
#| fig-width: 7
#| fig-height: 4
#| warning: false
#| message: false
#| echo: true

df_permanova %>%
  group_by(Species) %>%
  mutate(L = mean(Sepal.Length), A = mean(Sepal.Width)) %>%
  ggplot(aes(Sepal.Length, Sepal.Width, color = Species)) +
  geom_point(size = 2, alpha = 0.8) +
  geom_point(aes(x = L, y = A), size = 4, shape = 18) +
  geom_segment(aes(xend = L, yend = A), linetype = "dashed") +
  theme_classic() +
  labs(x = "Sepal.Length", y = "Sepal.Width")

```
```{r}
#| label: fig-permanova-box
#| fig-cap: "Distribución por variable y especie (perMANOVA)"
#| fig-width: 7
#| fig-height: 4
#| warning: false
#| message: false
#| echo: true

df_permanova %>%
  pivot_longer(cols = c(Sepal.Length, Sepal.Width), 
               names_to = "Variable", values_to = "Valor") %>%
  ggplot(aes(Variable, Valor, fill = Species)) +
  geom_boxplot() +
  theme_classic() +
  scale_fill_brewer(palette = "Set2")

```
