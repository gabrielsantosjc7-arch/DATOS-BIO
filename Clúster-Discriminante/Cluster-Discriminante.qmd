```{r}
#| label: clust_prep
#| warning: false
#| message: false

# Librerías necesarias
library(tidyverse)    # manipulación de datos y ggplot2
library(cluster)      # silhouette, pam, etc.
library(factoextra)   # funciones para visualizar clustering y gap statistic
library(NbClust)      # selección de k por múltiples índices
library(clusterCrit)  # índices de validación (opcional)
library(dendextend)   # manipular dendrogramas
library(knitr)        # kable()
library(kableExtra)   # estilo de tablas
library(clustertend)  # get_clust_tendency (Hopkins)

# Cargar dataset y preparar
data("USArrests")
A_raw <- USArrests %>% as_tibble(rownames = "region")

# Guardar copia original para auditoría
A_orig <- A_raw

# Selección de variables numéricas y escalado (estandarizar)
num_vars <- A_raw %>% select(Murder, Assault, UrbanPop, Rape)
num_scaled <- scale(num_vars) %>% as_tibble() %>% setNames(colnames(num_vars))
```

## Preparación de la matriz para clustering

```{r}
#| label: tbl-clust-prep
#| tbl-cap: "Resumen numérico de variables para clustering"
#| warning: false
#| message: false

summary_tbl <- num_vars %>%
summarise(across(everything(), list(mean = ~mean(.), sd = ~sd(.),
min = ~min(.), max = ~max(.)))) %>%
pivot_longer(everything(), names_to = c("variable","stat"), names_sep = "_") %>%
pivot_wider(names_from = stat, values_from = value) %>%
select(variable, mean, sd, min, max)

knitr::kable(summary_tbl, digits = 3)


```{r}
#| label: tbl-clust-hopkins
#| warning: false
#| message: false
#| tbl-cap: "Test de tendencia al agrupamiento (Hopkins)"

# Hopkins
set.seed(42)
hopkins_stat <- get_clust_tendency(num_scaled, n = nrow(num_scaled) - 1, 
                                   graph =FALSE)$hopkins_stat

hopkins_res <- tibble(test = "Hopkins", value = round(hopkins_stat, 3))
knitr::kable(hopkins_res, caption = "")
## Elección del número de clusters (validación)

```{r}
#| label: tbl-clust-k
#| tbl-cap: "Silhouette promedio por número de clusters (k)"
#| warning: false
#| message: false

# Distancia Euclidiana y Ward.D2
dist_mat <- dist(num_scaled, method = "euclidean")
hc <- hclust(dist_mat, method = "ward.D2")

# Silhouette promedio para k = 2..6 (kmeans)
sil_vals <- tibble(k = 2:6, sil_avg = NA_real_)
for (k in 2:6) {
km <- kmeans(num_scaled, centers = k, nstart = 50)
sil <- silhouette(km$cluster, dist_mat)
sil_vals$sil_avg[sil_vals$k == k] <- mean(sil[, 3])
}
knitr::kable(sil_vals, digits = 3)
```

```{r}
#| label: fig-clust-gap
#| fig-cap: "Análisis del Gap statistic"
#| warning: false
#| message: false

# Gap statistic
set.seed(42)
gap <- clusGap(num_scaled, FUN = kmeans, K.max = 6, B = 50)
fviz_gap_stat(gap)  # figura
```
```{r}
#| label: fig-clust-kmeans
#| fig-cap: "K-means (k = 2) y representación en PC1-PC2"
#| fig-width: 7
#| fig-height: 5
#| warning: false
#| message: false

# Ejecutar k-means con el k elegido (aquí usamos el k con mayor sil_avg)
k_opt <- sil_vals$k[which.max(sil_vals$sil_avg)]
set.seed(42)
km_res <- kmeans(num_scaled, centers = k_opt, nstart = 50)

# Añadir cluster al df original
df_clust <- A_raw %>% mutate(cluster_k = factor(km_res$cluster))

# Visualizar clusters sobre PC1-PC2 (representación)
fviz_cluster(km_res, data = num_scaled, geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal())

```{r}
#| label: tbl-clust-summary
#| tbl-cap: "Resumen comparativo de variables por clúster"
#| warning: false
#| message: false

# Calcular medias por grupo en variables escaladas
cluster_summary <- num_scaled %>%
  mutate(cluster = km_res$cluster) %>%
  pivot_longer(-cluster, names_to = "variable", values_to = "valor") %>%
  group_by(cluster, variable) %>%
  summarise(mean = mean(valor), .groups = "drop") %>%
  pivot_wider(names_from = variable, values_from = mean)

# Reordenar etiquetas de clúster según la media de Murder
cluster_order <- cluster_summary %>%
  mutate(avg_violence = Murder) %>%
  arrange(avg_violence) %>%
  mutate(new_cluster = row_number())

# Crear un vector de equivalencia
mapping <- cluster_order$new_cluster
names(mapping) <- cluster_order$cluster

# Reetiquetar clusters en los datos originales
df_clust <- A_raw %>%
  mutate(cluster_k = factor(mapping[km_res$cluster]))

# Actualizar cluster_summary con nuevas etiquetas
cluster_summary <- cluster_summary %>%
  mutate(cluster = mapping[cluster]) %>%
  arrange(cluster)

# Tabla con medias reordenadas
knitr::kable(cluster_summary, digits = 2)
## Clustering jerárquico (HC)

```{r}
#| label: tbl-hc-summary
#| tbl-cap: "Resumen comparativo de variables por clúster (clustering jerárquico)"
#| warning: false
#| message: false

# Cortar el dendrograma en 2 grupos
grupos_hc <- cutree(hc, k = 2)

# Calcular medias estandarizadas por grupo
hc_summary <- num_scaled %>%
  mutate(cluster = grupos_hc) %>%
  pivot_longer(-cluster, names_to = "variable", values_to = "valor") %>%
  group_by(cluster, variable) %>%
  summarise(mean = mean(valor), .groups = "drop") %>%
  pivot_wider(names_from = variable, values_from = mean)

# Mostrar tabla resumen
knitr::kable(hc_summary, digits = 2)

```
```{r}
#| label: fig-clust-dend
#| fig-cap: "Dendrograma (clustering jerárquico, método Ward.D2 sobre variables estandarizadas)"

# Asignar colores según interpretación previa
colores <- c("firebrick", "forestgreen")

# Graficar dendrograma
plot(hc, hang = -1, labels = A_raw$region,
     main = "Dendrograma - Ward.D2",
     xlab = "", sub = "")

# Dibujar rectángulos de los dos clústeres
rect.hclust(hc, k = 2, border = colores)

# Agregar leyenda
legend("topright",
       legend = c("Cluster 1: alta criminalidad", 
                  "Cluster 2: baja criminalidad"),
       col = colores,
       lwd = 3, cex = 0.9, box.lwd = 0.8, bg = "white")

```
