```{r}
#| label: tbl-glm-prep
#| tbl-cap: "Distribución de la variable respuesta (long_bill)"

# Crear variable binaria: "pico largo" (ejemplo umbral = 45 mm)
df_glm <- df %>%
  janitor::clean_names() %>%
  mutate(
    long_bill = case_when(
      !is.na(bill_length_mm) & bill_length_mm > 45 ~ 1,
      !is.na(bill_length_mm) & bill_length_mm <= 45 ~ 0,
      TRUE ~ NA_real_
    )
  ) %>%
  select(species, island, flipper_length_mm, bill_length_mm, long_bill) %>%
  drop_na(flipper_length_mm, long_bill) # quitar filas sin predictor o respuesta

# Comprobar distribución de la variable binaria
df_glm %>% 
  count(long_bill) %>% 
  knitr::kable()
## Ajuste del GLM binomial (logit)

```{r}
#| label: tbl-glm-fit
#| tbl-cap: "Coeficientes (logit) y Odds Ratios (OR)"

# Ajuste GLM binomial: probabilidad de pico largo según flipper_length y especie
modelo_glm <- glm(long_bill ~ flipper_length_mm + species,
                  data = df_glm,
                  family = binomial(link = "logit"))

# Tabla de coeficientes y OR (odds ratios)
glm_coef <- broom::tidy(modelo_glm, conf.int = TRUE) %>%
  mutate(
    estimate = round(estimate, 4),
    std.error = round(std.error, 4),
    p.value = ifelse(p.value < 0.001, "< 0.001", round(p.value, 3)),
    OR = round(exp(estimate), 3),
    OR_lwr = round(exp(conf.low), 3),
    OR_upr = round(exp(conf.high), 3)
  )

knitr::kable(glm_coef)

```
```{r}
#| label: tbl-glm-summary
#| warning: false
#| tbl-cap: "Resumen del ajuste GLM (desviancias, AIC, logLik)"

# Resumen del ajuste GLM: desviancias, AIC, logLik
glm_glance <- broom::glance(modelo_glm) %>%
  tibble::as_tibble() %>%
  select(null.deviance, df.null, deviance, df.residual, AIC, logLik) %>%
  mutate(across(where(is.numeric), round, 3))

knitr::kable(glm_glance)

```
## Diagnósticos GLM: overdispersion y AUC / performance

```{r}
#| label: tbl-glm-diagnostics
#| tbl-cap: "Diagnósticos GLM: overdispersion, accuracy y AUC"

# Overdispersion:ratio deviance/df.residual

dispersion <- with(summary(modelo_glm), deviance / df.residual)

# Predicciones y matriz de confusión simple (umbral 0.5)
df_glm <- df_glm %>%
  mutate(
    fitted_prob = predict(modelo_glm, type = "response"),
    fitted_class = ifelse(fitted_prob >= 0.5, 1, 0)
  )

conf_tab <- table(Actual = df_glm$long_bill, Predicho = df_glm$fitted_class)
accuracy <- sum(diag(conf_tab)) / sum(conf_tab)

# AUC / ROC
roc_obj <- pROC::roc(df_glm$long_bill, df_glm$fitted_prob, quiet = TRUE)
auc_val <- round(pROC::auc(roc_obj), 3)

# Tablas resumen
diag_table <- tibble(
  measure = c("Dispersion (deviance/df)", "Accuracy (threshold 0.5)", "AUC"),
  value = c(round(dispersion, 3), round(accuracy, 3), auc_val)
)

knitr::kable(diag_table)
```

```{r}
#| label: tbl-glm-confusion
#| tbl-cap: "Matriz de confusión (GLM, umbral 0.5)"

knitr::kable(as.data.frame(conf_tab))

```

## Predicciones: tabla presentable y ejemplo de interpretación

```{r}
#| label: tbl-glm_pred_table
#| tbl-cap: "Predicciones (probabilidad de pico largo)                            por flipper_length y especie"

# Predicción para valores representativos de flipper por especie
newdata <- expand.grid(
  flipper_length_mm = c(170, 190, 210),
  species = unique(df_glm$species)
) %>%
  as_tibble()

preds <- newdata %>%
  mutate(
    fit_prob = predict(modelo_glm, newdata = newdata, type = "response"),
    lwr = NA_real_, upr = NA_real_
  )

# obtener IC por link (logit) y transformar a prob (opcional)
pred_link <- predict(modelo_glm, newdata = newdata, se.fit = TRUE, 
                     type = "link")
crit <- qnorm(0.975)
preds <- preds %>%
  mutate(
    fit = round(plogis(pred_link$fit), 3),
    lwr = round(plogis(pred_link$fit - crit * pred_link$se.fit), 3),
    upr = round(plogis(pred_link$fit + crit * pred_link$se.fit), 3)
  )

knitr::kable(preds)

```

## Ajuste GLMM (efecto aleatorio por isla)

```{r}
#| label: tbl-glmm-fit
#| tbl-cap: efectos fijos (coeficientes y OR)
#| warning: false


# Ajuste GLMM (binomial) con intercepto aleatorio por isla
modelo_glmm <- glmer(long_bill ~ flipper_length_mm + species + (1 | island),
            data = df_glm,
            family = binomial(link = "logit"),
            control = glmerControl(optimizer = "bobyqa", 
                        optCtrl = list(maxfun = 200000)))

# Coeficientes fijados (fixed effects) y efecto aleatorio (varianza)
glmm_tidy <- broom.mixed::tidy(modelo_glmm, effects = "fixed", 
          conf.int = TRUE) %>%
  mutate(
    estimate = round(estimate, 4),
    OR = round(exp(estimate), 3),
    p.value = ifelse(p.value < 0.001, "< 0.001", round(p.value, 3))
  )

rand_eff <- as.data.frame(VarCorr(modelo_glmm))
rand_eff_tbl <- tibble(
  term = rand_eff$grp,
  variance = round(rand_eff$vcov, 4)
)

knitr::kable(glmm_tidy)

```

```{r}
#| label: tbl-glmm-var-fit
#| tbl-cap: Varianza del efecto aleatorio (island)

knitr::kable(rand_eff_tbl)
```
